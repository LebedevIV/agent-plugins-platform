# Контекст Проекта - Видение и Архитектура

## Видение Проекта

### Цель
Agent-Plugins-Platform (APP) - это браузерное расширение, которое позволяет выполнять Python плагины в браузере с использованием Pyodide и протокола MCP (Model Context Protocol). Проект фокусируется на безопасности, производительности и удобстве разработки.

### Ключевые Принципы
- **Безопасность**: Полная изоляция плагинов в sandbox
- **Производительность**: Оптимизированная загрузка и выполнение
- **UX**: Интуитивный интерфейс с автоматическим сохранением состояния
- **Расширяемость**: Модульная архитектура для легкого добавления плагинов

## Архитектура

### Основные Компоненты

#### 1. Plugin Manager (`core/plugin-manager.js`)
- Управляет жизненным циклом плагинов
- Координирует загрузку и выполнение
- Обеспечивает изоляцию между плагинами

#### 2. Host API (`core/host-api.js`)
- Предоставляет доступ к браузерным API для Python
- Обеспечивает безопасный интерфейс
- Валидирует все запросы

#### 3. Workflow Engine (`core/workflow-engine.js`)
- Выполняет рабочие процессы плагинов
- Управляет последовательностью операций
- Обрабатывает ошибки и откаты

#### 4. MCP Bridge (`bridge/mcp-bridge.js`)
- Обеспечивает коммуникацию между JavaScript и Python
- Реализует протокол MCP
- Обрабатывает сериализацию данных

#### 5. Pyodide Worker (`bridge/pyodide-worker.js`)
- Изолированное выполнение Python кода
- Управляет Pyodide runtime
- Обеспечивает sandboxing

### Структура Плагина
```
public/plugins/plugin-name/
├── manifest.json      # Метаданные и разрешения плагина
├── mcp_server.py      # Python реализация MCP протокола
├── workflow.json      # Определение рабочего процесса
└── icon.svg          # Иконка плагина
```

### Поток Коммуникации
1. UI → Plugin Manager → MCP Bridge → Pyodide Worker → Python Plugin
2. Python Plugin → Host API → Browser APIs
3. Результаты возвращаются по тому же пути

## Технический Стек

### Frontend
- **JavaScript/TypeScript**: Основной язык разработки
- **ES6+**: Современные возможности языка
- **Async/Await**: Асинхронное программирование
- **Web Workers**: Изоляция выполнения

### Backend (Python)
- **Pyodide**: Python в браузере
- **MCP Protocol**: Стандартизированная коммуникация
- **Async Python**: Асинхронное выполнение

### Браузерные API
- **Chrome Extensions API**: Manifest V3
- **Sidebar API**: Боковая панель
- **Storage API**: Локальное хранение
- **Tabs API**: Управление вкладками

### AI Интеграция
- **Google Gemini API**: Многоуровневая система моделей
  - Gemini Flash: Базовая аналитика
  - Gemini Pro: Детальное сравнение
  - Gemini 2.5 Pro: Глубокий анализ
- **Fallback Strategy**: Автоматический переход между моделями
- **Rate Limiting**: Обработка лимитов API

## Структура Файлов

### Основные Файлы
- `manifest.json`: Конфигурация расширения (Manifest V3)
- `package.json`: Зависимости Node.js и скрипты
- `vite.config.js`: Конфигурация сборки
- `index.html`: Главная точка входа приложения
- `test-harness.js`: Интерфейс тестирования для разработки

### Разработка Плагинов
- Плагины создаются в `public/plugins/`
- Следуют соглашению именования: `plugin-name/`
- Включают полные метаданные в manifest.json
- Реализуют MCP протокол в mcp_server.py
- Определяют рабочие процессы в workflow.json

### Сборка и Развертывание
- `npm run dev`: Для разработки
- `npm run build`: Для продакшена
- Тестирование расширения в режиме разработчика браузера
- Валидация безопасности плагинов перед распространением

## Общие Паттерны

### Структура Манифеста Плагина
```json
{
  "name": "Plugin Name",
  "version": "1.0.0",
  "description": "Plugin description",
  "main_server": "mcp_server.py",
  "host_permissions": ["*://*.example.com/*"],
  "permissions": ["activeTab", "scripting"]
}
```

### Формат MCP Сообщения
```javascript
{
  "type": "request|response|notification",
  "id": "unique-message-id",
  "method": "function-name",
  "params": { /* parameters */ },
  "result": { /* result */ }
}
```

### Шаблон Python Плагина
```python
import sys
import json
from typing import Any, Dict

async def main():
    line = sys.stdin.readline()
    request = json.loads(line)
    
    # Обработка запроса
    result = await process_request(request)
    
    # Отправка ответа
    response = {"result": result}
    sys.stdout.write(json.dumps(response) + '\n')

async def process_request(request: Dict[str, Any]) -> Dict[str, Any]:
    # Логика плагина здесь
    return {"status": "success"}
```

## Безопасность

### Валидация Плагинов
- Проверка манифестов плагинов
- Валидация требований разрешений
- Сканирование на вредоносный код
- Проверка подписей плагинов

### Runtime Безопасность
- Принуждение границ sandbox
- Валидация всех входных данных
- Мониторинг поведения плагинов
- Реализация rate limiting

### Защита Данных
- Санитизация всех пользовательских данных
- Шифрование чувствительной информации
- Реализация безопасной коммуникации
- Аудит паттернов доступа к данным

## Производительность

### Оптимизация Запуска
- Ленивая загрузка Pyodide runtime
- Кэширование манифестов плагинов
- Оптимизация размера бандла
- Использование service worker кэширования

### Runtime Оптимизация
- Реализация кэширования результатов плагинов
- Оптимизация использования памяти
- Использование эффективных структур данных
- Минимизация cross-worker коммуникации

### Управление Памятью
- Очистка ресурсов WebWorker
- Мониторинг использования памяти
- Реализация подсказок для garbage collection
- Ограничение одновременного выполнения плагинов 